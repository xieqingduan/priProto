# priProto 基于netty5基于私有协议栈设计

## 通讯模型
![](https://raw.githubusercontent.com/xieqingduan/priProto/master/src/main/resources/image/netty.png)

具体步骤如下。

（1）Netty协议栈客户端发送握手请求消息，携带节点ID等有效身份认证信息；

（2）Netty协议栈服务端对握手请求消息进行合法性校验，包括节点ID有效性校验、节点重复登录校验和IP地址合法性校验，校验通过后，返回登录成功的握手应答消息；

（3）链路建立成功之后，客户端发送业务消息；

（4）链路成功之后，服务端发送心跳消息；

（5）链路建立成功之后，客户端发送心跳消息；

（6）链路建立成功之后，服务端发送业务消息；

（7）服务端退出时，服务端关闭连接，客户端感知对方关闭连接后，被动关闭客户端连接。

## 消息定义
Netty协议栈消息定义包含两部分：   
    •消息头；   
    •消息体。

    public class NettyMessage {    
        private Header header;  //消息头
        private Object body;    //消息体


    public class Header {
        private int crcCode = 0xabef0101;  //校验码+协议号+版本号
        private int length;                //消息长度
        private long sessionID;            //会话id
        private byte type;                 //消息类型
        private byte priority;             //消息优先级
        private Map<String,Object> attachment = new HashMap<String, Object>();//消息附件

## 链路的建立

 客户端与服务端链路建立成功之后，由客户端发送握手请求消息，握手请求消息的定义如下。

（1）消息头的type字段值为3；

（2）可选附件为个数为0；

（3）消息体为空；

（4）握手消息的长度为22个字节。服务端接收到客户端的握手请求消息之后，如果IP校验通过，返回握手成功应答消息给客户端，应用层链路建立成功。握手应答消息定义如下。


 服务端接收到客户端的握手请求消息之后，如果IP校验通过，返回握手成功应答消息给客户端，应用层链路建立成功。握手应答消息定义如下。

（1）消息头的type字段值为4；

（2）可选附件个数为0；

（3）消息体为byte类型的结果，“0”表示认证成功；“-1”表示认证失败。链路建立成功之后，客户端和服务端就可以互相发送业务消息了。

## 可靠性设计

 ### 心跳机制
 具体的设计思路如下。
 
 （1）当网络处于空闲状态持续时间达到T（连续周期T没有读写消息）时，客户端主动发送Ping心跳消息给服务端。
 
 （2）如果在下一个周期T到来时客户端没有收到对方发送的Pong心跳应答消息或者读取到服务端发送的其他业务消息，则心跳失败计数器加1。
 
 （3）每当客户端接收到服务的业务消息或者Pong应答消息时，将心跳失败计数器清零；连续N次没有接收到服务端的Pong消息或者业务消息，则关闭链路，间隔INTERVAL时间后发起重连操作。
 
 （4）服务端网络空闲状态持续时间达到T后，服务端将心跳失败计数器加1；只要接收到客户端发送的Ping消息或者其他业务消息，计数器清零。
 
 （5）服务端连续N次没有接收到客户端的Ping消息或者其他业务消息，则关闭链路，释放资源，等待客户端重连。
 
 通过Ping-Pong双向心跳机制，可以保证无论通信哪一方出现网络故障，都能被及时地检测出来。为了防止由于对方短时间内繁忙没有及时返回应答造成的误判，只有连续N次心跳检测都失败才认定链路已经损害，需要关闭链路并重建链路。
 
 ### 重连机制
 如果链路中断，等待INTERVAL时间后，由客户端发起重连操作，如果重连失败，间隔周期INTERVAL后再次发起重连，直到重连成功。
 
 为了保证服务端能够有充足的时间释放句柄资源，在首次断连时客户端需要等待INTERVAL时间之后再发起重连，而不是失败后就立即重连。
 
 为了保证句柄资源能够及时释放，无论什么场景下的重连失败，客户端都必须保证自身的资源被及时释放，包括但不限于SocketChannel、Socket等。
 
 重连失败后，需要打印异常堆栈信息，方便后续的问题定位。
 
 ### 重复登录保护
 当客户端握手成功之后，在链路处于正常状态下，不允许客户端重复登录，以防止客户端在异常状态下反复重连导致句柄资源被耗尽。
 
 服务端接收到客户端的握手请求消息之后，首先对IP地址进行合法性检验，如果校验成功，在缓存的地址表中查看客户端是否已经登录，如果已经登录，则拒绝重复登录，返回错误码-1，同时关闭TCP链路，并在服务端的日志中打印握手失败的原因。
 
 客户端接收到握手失败的应答消息之后，关闭客户端的TCP连接，等待INTERVAL时间之后，再次发起TCP连接，直到认证成功。
 
 为了防止由服务端和客户端对链路状态理解不一致导致的客户端无法握手成功的问题，当服务端连续N次心跳超时之后需要主动关闭链路，清空该客户端的地址缓存信息，以保证后续该客户端可以重连成功，防止被重复登录保护机制拒绝掉。
 
 ### 安全性设计
 为了保证整个集群环境的安全，内部长连接采用基于IP地址的安全认证机制，服务端对握手请求消息的IP地址进行合法性校验：如果在白名单之内，则校验通过；否则，拒绝对方连接。
 
 如果将Netty协议栈放到公网中使用，需要采用更加严格的安全认证机制，例如基于密钥和AES加密的用户名+密码认证机制，也可以采用SSL/TSL安全传输。
 
 作为示例程序，Netty协议栈采用最简单的基于IP地址的白名单安全认证机制。
 
 ### 可扩展性设计
 
 Netty协议需要具备一定的扩展能力，业务可以在消息头中自定义业务域字段，例如消息流水号、业务自定义消息头等。通过Netty消息头中的可选附件attachment字段，业务可以方便地进行自定义扩展。
 
 Netty协议栈架构需要具备一定的扩展能力，例如统一的消息拦截、接口日志、安全、加解密等可以被方便地添加和删除，不需要修改之前的逻辑代码，类似Servlet的Filter Chain和AOP，但考虑到性能因素，不推荐通过AOP来实现功能的扩展。